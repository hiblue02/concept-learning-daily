## 스프링

### 스프링 Interceptor
스프링 프레임워크의, 스프링 MVC에서 HTTP 요청과 응답을 가로채어 처리하는 기능
#### 주요기능 
1. Controller가 요청을 받기 전에 가로채어 처리할 수 있다.
2. Controller 응답 후 뷰 랜더링 전에 응답을 가로채어 처리할 수 있다.
3. 뷰 렌더링 후 가로채어 처리할 수 있다.
#### 구현 방법
HandlerInterceptor 인터페이스를 구현하면 된다. HandlerInterceptor는 아래 메소드를 포함한다. 
1. preHandle: Controller가 요청을 처리하기 전에 호출된다.
```java
boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;
```
2. postHandle: 요청을 처리한 후 뷰가 렌더링 되기 전에 호출된다.
```java
void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception;
```
3. afterCompletion: 뷰 렌더링이 완료된 후 호출된다.
```java
void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception;
```   
#### 인터셉터 추가하기 
```java
@Configuration
public class WebConfig implement WebMvcConfigurer {
  private final MyInterceptor myInterceptor;
  public WebConfig(MyInterceptor myInterceptor) {
        this.myInterceptor = myInterceptor;
    }

   @Override
   public void addInterceptors(InterceptorRegistry registry) {
       registry.addInterceptor(myInterceptor);
   }
}
```
#### 사용 예시 
1. 보안: 사용자 인증 및 권한 검사를 요청 전에 수행하는 경우
2. 로그 기록: 요청 및 응답에 대한 정보를 기록하는 경우
3. 데이터 변환: 요청이나 응답 데이터를 수정하는 경우
4. 성능: 캐싱을 구현하거나 요청 처리를 최적화하는 경우

### 스프링 TransactionSynchronization 
스프링에서 트랜잭션의 상태에 따라 특정 작업을 수행할 수 있도록 해주는 인터페이스. 
#### 주요 기능
1. beforeCommit(boolean readOnly): 트랜잭션이 commit 되기 전에 호출된다.
  - `readOnly` 플래그는 트랜잭션이 읽기 전용인지 여부를 나타낸다.
  - 트랜잭션이 커밋되기 전에 검증 작업이나 준비 작업을 수행할 때 사용한다.
2. afterCommit(): 트랜잭션이 성공적으로 commit된 후 호출된다.
  - 트랜잭션이 완료된 이후에 실행해야 하는 작업(외부 시스템에 알림을 보내거나, 캐시를 업데이트 하는 작업 등)을 수행할 때 유용하다.
3. beforeCompletion(): 트랜잭션이 commit되거나 rollback되기 전에 호출된다.
4. afterCompletion(int status): 트랜잭션이 commit되거나 rollack된 후 호출된다.
  - `status` 플래그는 트랜잭션이 commit됐는지 rollback됐는지를 나타낸다.
5. flush: 트랜잭션 플러시
  - 변경사항을 DB에 즉시 반영하도록 강제한다.
  - TransactionSynchronization에서 직접 구현하지 않고 EntityManger나 Session 객체에서 호출된다.
6. resume: 중단된 트랜잭션을 다시 활성화 한다.
7. suspend: 현재 트랜잭션을 일시적으로 중단한다.
  - 트랜잭션을 일시적으로 중단하고 다른 트랜잭션을 시작하거나, 현재 트랜잭션의 상태를 유지하면서 다른 작업을 수행할 수 있게 한다.
  - 중단된 트랜잭션은 나중에 resume() 메서드를 호출하여 다시 활성화할 수 있다.    
#### 구현 방법
TransactionSynchronization을 구현한다. 
```java
public class MyTransactionSynchronization implements TransactionSynchronization {
  @Override
  public void beforeCommit(boolean readOnly) {
    if(!readOnly) {}
  }
  @Override
  public void afterCommit() {

  }

  @Override
  public void beforeCompletion() {
  }

  @Override
  public void afterCompletion(int status) {
      if(status == STATUS_COMPLETED) {} else if (status == STATUS_ROLLED_BACK){}
  }
}
```
TransactionSynchronizationMananger로 등록할 수 있다. 
```java
 TransactionSynchronizationManager.registerSynchronization(new MyTransactionSynchronization());
```
## 스프링 스케쥴드 
자바 애플리케이션이 주기적인 작업을 수행할 수 있도록 도와주는 기능이다. `@Scheduled` 애노테이션을 사용해여 특정 메서드를 주기적으로 설정할 수 있다. 
### 주요 개념 
1. 기본 설정
- 스프링 스케쥴링 기능을 사용하려면 @EnabledScheduling 애노테이션을 사용해여 스케쥴링 기능을 활성화해야 한다. 
```java
@Configuration
@EnableScheduling
public class AppConfig {
}
```
2. `@Scheduled`
- 주기적으로 실행할 메서드에 @Scheduled 애노테이션을 붙인다. fixedRate, fixedDelay, cron 속성을 사용해 실행 주기를 설정할 수 있다. 
```java
@Component
public class ScheduledTasks {
  @Scheduled(fixedRate=5000) //5초마다 실행
  public void performTask() {
    
  }
  @Scheduled(fixedDelay = 10000) // 이전 작업 종료 후 10초 후 실행 
  public void performTaskWithDelay() {
      
  }
  @Scheduled(crom = "0 0 * * * *") // 매 시간 정각에 실행
  public void performTaskWithCrom() {
  }
} 
```
3. 속성
- `fixtedRate`: 밀리초 단위로 주기를 설정한다. 메서드가 실행된 후 일정 시간이 경과한 후 다음 실행이 시작된다. 
- `fixtedDelay`: 메서드가 실행을 완료한 후, 일정 시간이 경과한 후 다음 실행이 시작된다. 
- `cron`: 크론 표현식을 사용해 복접한 일정 주기를 설정할 수 있다. 매일 자정에 작업을 하려면, `0 0 0 * * *`으로 설정할 수 있다. 
4. 스케줄러 설정 
- 기본적으론, ThreadPoolTaskScheduler를 사용한다. 필요에 따라 사용자 정의 TaskScheduler를 설정할 수 도 있다.
5. 에러 처리 및 트랜잭션 
- 스케줄링 작업이 실패하면 기본적으로 로그를 기록하고 계속 실행한다. 에러 처리를 추가로 구현하거나 트랜잭션 처리가 필요한 경우 적절한 설정을 고려해야 한다. 
## 스프링 리트라이
스프링 리트라이는 실패한 작업을 재작업할 수 있는 기능을 제공한다. 주로 실패한 작업을 자동으로 재시도할 수 있다. 
주로 네트워크 요청이나 외부 서비스 호출에서 일시적인 오류를 처리할 때 유용합니다. 
### 주요 개념 
1. 재시도(Retry): 실패한 작업을 일정 횟수만큼 자동으로 다시 시도한다.(maxAttempts 옵션, 최대 횟수)
2. 백오프(BackOff): 재시도 대기 시간을 조절하는 방식이다.(delay 옵션) 재시도 시간을 점점 늘릴 수도 있다. (multiplier 옵션)
3. 서킷브레이커(Circuit Breaker): 일정한 실패 횟수나 비율에 따라 다른 경로로 우회하는 방법이다. 
### 주요 애노테이션 
1. @Retryable: 메서드가 실패할 경우, 자동으로 재시도하도록 설정한다.
2. @Recover: 재시도 후에도 실패할 경우, 호출한 메서드를 설정한다.
### 사용 예시 
```java
@Service
public class MyService {

    @Retryable(
        value = { SomeException.class },
        maxAttempts = 5,
        backoff = @Backoff(delay = 2000, multiplier = 2) 
    )
    public void performTask() throws SomeException {
        // 작업 수행 코드
    }

    @Recover
    public void recover(SomeException e) {
        // 재시도 후에도 실패할 경우 대체 처리 로직
    }
} 
```

## 스프링 시큐리티 보안 필터 체인
인증 및 인가를 관리하기 위한 필터를 정의하고 구성하는 매커니즘이다. 
필터 체인은 요청이 처리되는 순서가 매우 중요하다. 
사용자 정의 필터를 추가할 수 있다. 
### 주요 구성요소 
1. 필터
  - 스프링 시큐리티에선 다양한 종류의 필터가 제공된다. 각 필터는 특정 보안 기능을 수행한다.
  - UsernamePasswordAuthenticationFilter는 사용자 이름과 비밀번호를 기반으로 인증을 처리한다. 
2. 필터 체인
  - 여러 개의 필터를 순서대로 실행한다. 요청이 들어오면 필터가 차례로 호출된다. 
  - 필터는 요청을 처리하고, 필요한 경우 다음 필터로 요청을 전달한다.  
3. URL 패턴
  - 각 필터는 특정 URL에 작동하도록 구성할 수 있다. 특정 요청에 대한 보안 조치를 적용하거나 제외할 수 있다. 
### 필터 체인 구성 방법 
```kotlin
@Configuration
@EnableWebSecurity
class SecurityConfig: WebSecurityConfigurerAdapter() {
  override fun configure(http: HttpSecurity) {
      http
        .authroizedRequest()
        .antMathers("/public/**").permitAll()
        .anyRequest().authenticated()
      .and()
      .formLogin()
      .and()
      .logout()
  }
}
```
