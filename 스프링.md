## 스프링

### 스프링 Interceptor
스프링 프레임워크의, 스프링 MVC에서 HTTP 요청과 응답을 가로채어 처리하는 기능
#### 주요기능 
1. Controller가 요청을 받기 전에 가로채어 처리할 수 있다.
2. Controller 응답 후 뷰 랜더링 전에 응답을 가로채어 처리할 수 있다.
3. 뷰 렌더링 후 가로채어 처리할 수 있다.
#### 구현 방법
HandlerInterceptor 인터페이스를 구현하면 된다. HandlerInterceptor는 아래 메소드를 포함한다. 
1. preHandle: Controller가 요청을 처리하기 전에 호출된다.
```java
boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;
```
2. postHandle: 요청을 처리한 후 뷰가 렌더링 되기 전에 호출된다.
```java
void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception;
```
3. afterCompletion: 뷰 렌더링이 완료된 후 호출된다.
```java
void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception;
```   
#### 인터셉터 추가하기 
```java
@Configuration
public class WebConfig implement WebMvcConfigurer {
  private final MyInterceptor myInterceptor;
  public WebConfig(MyInterceptor myInterceptor) {
        this.myInterceptor = myInterceptor;
    }

   @Override
   public void addInterceptors(InterceptorRegistry registry) {
       registry.addInterceptor(myInterceptor);
   }
}
```
#### 사용 예시 
1. 보안: 사용자 인증 및 권한 검사를 요청 전에 수행하는 경우
2. 로그 기록: 요청 및 응답에 대한 정보를 기록하는 경우
3. 데이터 변환: 요청이나 응답 데이터를 수정하는 경우
4. 성능: 캐싱을 구현하거나 요청 처리를 최적화하는 경우

### 스프링 TransactionSynchronization 
스프링에서 트랜잭션의 상태에 따라 특정 작업을 수행할 수 있도록 해주는 인터페이스. 
#### 주요 기능
1. beforeCommit(boolean readOnly): 트랜잭션이 commit 되기 전에 호출된다.
  - `readOnly` 플래그는 트랜잭션이 읽기 전용인지 여부를 나타낸다.
  - 트랜잭션이 커밋되기 전에 검증 작업이나 준비 작업을 수행할 때 사용한다.
2. afterCommit(): 트랜잭션이 성공적으로 commit된 후 호출된다.
  - 트랜잭션이 완료된 이후에 실행해야 하는 작업(외부 시스템에 알림을 보내거나, 캐시를 업데이트 하는 작업 등)을 수행할 때 유용하다.
3. beforeCompletion(): 트랜잭션이 commit되거나 rollback되기 전에 호출된다.
4. afterCompletion(int status): 트랜잭션이 commit되거나 rollack된 후 호출된다.
  - `status` 플래그는 트랜잭션이 commit됐는지 rollback됐는지를 나타낸다.
5. flush: 트랜잭션 플러시
  - 변경사항을 DB에 즉시 반영하도록 강제한다.
  - TransactionSynchronization에서 직접 구현하지 않고 EntityManger나 Session 객체에서 호출된다.
6. resume: 중단된 트랜잭션을 다시 활성화 한다.
7. suspend: 현재 트랜잭션을 일시적으로 중단한다.
  - 트랜잭션을 일시적으로 중단하고 다른 트랜잭션을 시작하거나, 현재 트랜잭션의 상태를 유지하면서 다른 작업을 수행할 수 있게 한다.
  - 중단된 트랜잭션은 나중에 resume() 메서드를 호출하여 다시 활성화할 수 있다.    
#### 구현 방법
TransactionSynchronization을 구현한다. 
```java
public class MyTransactionSynchronization implements TransactionSynchronization {
  @Override
  public void beforeCommit(boolean readOnly) {
    if(!readOnly) {}
  }
  @Override
  public void afterCommit() {

  }

  @Override
  public void beforeCompletion() {
  }

  @Override
  public void afterCompletion(int status) {
      if(status == STATUS_COMPLETED) {} else if (status == STATUS_ROLLED_BACK){}
  }
}
```
TransactionSynchronizationMananger로 등록할 수 있다. 
```java
 TransactionSynchronizationManager.registerSynchronization(new MyTransactionSynchronization());
```
## 스프링 스케쥴드 
자바 애플리케이션이 주기적인 작업을 수행할 수 있도록 도와주는 기능이다. `@Scheduled` 애노테이션을 사용해여 특정 메서드를 주기적으로 설정할 수 있다. 
### 주요 개념 
1. 기본 설정
- 스프링 스케쥴링 기능을 사용하려면 @EnabledScheduling 애노테이션을 사용해여 스케쥴링 기능을 활성화해야 한다. 
```java
@Configuration
@EnableScheduling
public class AppConfig {
}
```
2. `@Scheduled`
- 주기적으로 실행할 메서드에 @Scheduled 애노테이션을 붙인다. fixedRate, fixedDelay, cron 속성을 사용해 실행 주기를 설정할 수 있다. 
```java
@Component
public class ScheduledTasks {
  @Scheduled(fixedRate=5000) //5초마다 실행
  public void performTask() {
    
  }
  @Scheduled(fixedDelay = 10000) // 이전 작업 종료 후 10초 후 실행 
  public void performTaskWithDelay() {
      
  }
  @Scheduled(crom = "0 0 * * * *") // 매 시간 정각에 실행
  public void performTaskWithCrom() {
  }
} 
```
3. 속성
- `fixtedRate`: 밀리초 단위로 주기를 설정한다. 메서드가 실행된 후 일정 시간이 경과한 후 다음 실행이 시작된다. 
- `fixtedDelay`: 메서드가 실행을 완료한 후, 일정 시간이 경과한 후 다음 실행이 시작된다. 
- `cron`: 크론 표현식을 사용해 복접한 일정 주기를 설정할 수 있다. 매일 자정에 작업을 하려면, `0 0 0 * * *`으로 설정할 수 있다. 
4. 스케줄러 설정 
- 기본적으론, ThreadPoolTaskScheduler를 사용한다. 필요에 따라 사용자 정의 TaskScheduler를 설정할 수 도 있다.
5. 에러 처리 및 트랜잭션 
- 스케줄링 작업이 실패하면 기본적으로 로그를 기록하고 계속 실행한다. 에러 처리를 추가로 구현하거나 트랜잭션 처리가 필요한 경우 적절한 설정을 고려해야 한다. 
 

